% In this file you should put the actual content of the blueprint.
% It will be used both by the web and the print version.
% It should *not* include the \begin{document}
%
% If you want to split the blueprint content into several files then
% the current file can be a simple sequence of \input. Otherwise It
% can start with a \section or \chapter for instance.

\section{Basic definitions}

Given a possibly undefined expression or a partial element, we write $\defined{e}$ to indicate that the element is defined.

\begin{definition}
  \label{def:partial-application}
  %
  \lean{PartialApplication}
  \leanok
  %
  A \emph{partial application} on a set $A$ is a partial map ${-} \cdot_A {-} : A \times A \parto A$.
\end{definition}

\begin{definition}
  \label{def:PCA}
  %
  \leanok
  \lean{PCA}
  \uses{def:partial-application}
  %
  A set $A$ with a partial map ${-} \cdot {-}$ is a \emph{partial combinatory algebra (PCA)} if there are
  elements $\combK, \combS \in A$ such that, for all $a, b, c \in A$:
  %
  \begin{align*}
    &\defined{\combK \cdot a}, &
    &\combK \cdot a \cdot b = a \\
    &\defined{\combS \cdot a \cdot b}, &
    &\combS \cdot a \cdot b \cdot c = (a \cdot c) \cdot (b \cdot c).
  \end{align*}
\end{definition}


\section{Combinatory completeness}


\begin{definition}
  \label{def:expression}
  %
  \leanok
  \lean{Expr}
  %
  Given a set $\Gamma$ of \emph{variables} and a set $A$ of elements, the
  \emph{expressions} $\Expr \Gamma A$ are generated inductively by the following clauses:
  %
  \begin{itemize}
    \item the constants $\mathtt{K}$ and $\mathtt{S}$ are expressions,
    \item an element $a \in A$ is an expression,
    \item a variable $x \in \Gamma$ is an expression,
    \item if $e_1$ and $e_2$ are expressions then $e_1 \cdot e_2$ is an expression.
  \end{itemize}
\end{definition}

\noindent
The application $e_1 \cdot e_2$ in the third clause of the definition is formal, i.e., it is just a constructor of an inductive datatype.

\begin{definition}
  \label{def:extension}%
  \leanok
  \lean{Expr.Extend}
  \lean{Expr.extend}
  %
  A \emph{valuation} is a map $\eta : \Gamma \to A$ which assigns values to variables in~$\Gamma$.
  Given a valuation $\eta : \Gamma \to A$ over a context, $x \not\in \Gamma$ and $a \in A$, the
  \emph{extension} $\extendEnv \eta x a$ is a valuation on $\Gamma + \{x\}$, defined by:
  %
  \begin{equation*}
    (\extendEnv \eta x a) y =
    \begin{cases}
      \eta(y) &\text{if $y \in \Gamma$,}\\
      a       &\text{if $y = x$.}
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  \label{def:evaluation}
  %
  \leanok
  \lean{Expr.eval}
  %
  \uses{def:expression}
  \uses{def:PCA}
  %
  The \emph{evaluation} $\eval e \eta$ of an expression $e \in \Expr \Gamma A$ in a PCA~$A$ at a
  valuation $\eta : \Gamma \to A$ is defined recursively by the clauses
  %
  \begin{align*}
    \eval{\mathtt{K}}{\eta} &= \combK \\
    \eval{\\mathtt{S}}{\eta} &= \combK \\
    \eval{a}{\eta} &= a        &&\text{if $a \in A$}\\
    \eval{x}{\eta} &= \eta(x)  &&\text{if $x \in \Gamma$}\\
    \eval{e_1 \cdot e_2}{\eta} &= (\eval{e_1} \eta) \cdot_A (\eval{e_2} \eta).
  \end{align*}
  %
  The evaluation may be undefined.
\end{definition}

\begin{definition}
  \label{def:expression-defined}
  %
  \leanok
  \lean{Expr.defined}
  \uses{def:expression}
  \uses{def:evaluation}
  %
  An expression $e \in \Expr \Gamma A$ is \emph{defined} when $\defined{\eval{e}{\eta}}$
  for all $\eta : \Gamma \to A$.
\end{definition}


\begin{definition}
  \label{def:abstraction}
  %
  \leanok
  \lean{Expr.abstr}
  \uses{def:expression}
  \uses{def:extension}
  %
  Let $x \not\in \Gamma$,
  The \emph{abstraction} of an expression $e \in \Expr {(\Gamma \cup \{x\})} A$ 
  is the expression $\abstr{x} e \in \Expr \Gamma A$ defined recursively:
  %
  \begin{align*}
    \abstr{x} x &= \combS \cdot \combK \cdot \combK, \\
    \abstr{x} y &= \combK \cdot y &&\text{if $x \neq y \in \Gamma$}, \\
    \abstr{x} a &= \combK \cdot a &&\text{if $a \in A$}, \\
    \abstr{x} (e_1 \cdot e_2) &= \combS \cdot (\abstr{x} e_1) \cdot (\abstr{x} e_2).
  \end{align*}
\end{definition}


\begin{proposition}
  \label{prop:abstraction-defined}
  %
  \leanok
  \lean{Expr.defined_abstr}
  \uses{def:expression-defined}
  \uses{def:abstraction}
  %
  An abstraction $\abstr{x} e$ is defined.
\end{proposition}

\begin{proposition}
  \label{prop:abstraction-equal}
  %
  \leanok
  \lean{Expr.eq_abstr}
  \uses{def:expression}
  \uses{def:evaluation}
  \uses{def:abstraction}
  %
  Let $x \not\in \Gamma$ and $e \in \Expr {(\Gamma \cup \{x\})} A$.
  Then for every $a \in A$ and $\eta : \Gamma \to A$
  %
  \begin{equation*}
    \eval{(\abstr{x} e) \cdot a}{\eta} =
    \eval{e}{\extendEnv{\eta}{x}{a}}.
  \end{equation*}
\end{proposition}


\section{Programming with PCAs}

TODO

\section{Examples of PCAs}

TODO

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "print"
%%% End:
